\chapter{Umsetzung}

Umgesetzt wurde die Aufgabe im wesentlichen aus drei Teilen: 
\begin{itemize}
	\item Einer SQL-Datenbank mit realitätsnahen Tabellen 
	\item Einer Ontologie 
	\item Einem ausführbaren Programm mit Grafischer Benutzungsoberfläche

\end{itemize}

\section{Datenbank}

Als Plattform für die Datenbank war aufgrund der Tatsache, dass es viele lesende Zugriffe gibt und der leichteren Portierbarkeit SQLite im Gespräch. Letztendlich haben wir uns aus Gründen der Skalierbarkeit und der Erfahrungen dann doch für MySQL entschieden.

In der Datenbank wurden als wichtigste Tabelle "`Sport"' erstellt. Das Design ist in Abbildung \ref{dbd} zu finden


\begin{capfigure}[Datenbank-Design]
	\includegraphics[width=150mm]{images/db_design}
\end{capfigure}

TODO etwas mehr

\section{Ontologie}
\TODO{[PRIO:SOFORT] Komplett neu machen}

\section{Programm}
Das Programm wurde mit Java geschreiben und beinhaltet eine Swing-basierte GUI. Funktional ist sie angebunden an eine SQL-Datenbank und eine OWL-Datei, die die Ontologie repräsentiert. Das Optische Erscheinungsbild ist in zwei Fenster gegliedert: Dem Hauptfenster besehend aus den sechs Auswahlgruppen Art des Sports (Einzel- oder Team), Einem Eingabefenster für maximale Kosten, ein Zielefenster, Innen-Außen-Formular geeignet, Ziele Eigenschaften (Abbildung \ref{GUI1}). Das zweite Fenster ist ein "`Stundenplan"', bei dem durch Auswahl ganzer Tage oder einzelner Stunden im Gitter bei dem die ausgewählten möglichen Zeiträume grün dargestellt werden (Abbildung \ref{GUI2})

\begin{figure}%
\includegraphics[width=150mm]{images/gui.png}%
\caption{Startpunkt: Die GUI nach Programmaufruf}%
\label{GUI1}%
\end{figure}

\begin{figure}%
\includegraphics[width=150mm]{images/guizeit.png}%
\caption{Auswahl der Zeiten}%
\label{GUI2}%
\end{figure}

Durch den Knopf "`Suche Sportarten"' wird eine Recherche ausgelöst. Hierfür wird eine Ontologie- und Datenbankverbindung geöffnet.
Die Ontologieverbindung ist durch einen Shortform-Provider aus der OWL-API und einem HermIt-Reasoner realisiert. Letzterem wird über einen Stream unsere OWL-Datei übergeben. Hierfür gibt es die Klasse OntologyConnection, welche als Singleton-Klasse realisiert ist.

Die Datenbankverbindung wird durch einen JDBC-Treiber realisiert. Unsere gefüllte Datenbank liegt auf einem SQL-Server im Internet.

Das folgende Listing wird nach Auslösen des "`Suche Sportarten"'-Knopfes ausgeführt (präziser: Die doInBackground-Methode):


\begin{lstlisting}[language=JAVA]
	private class ExecuteQuery extends SwingWorker<Void, Void> {

		private DefaultListModel<Sportangebot> model = new DefaultListModel<Sportangebot>();
		private QueryBuilder builder;

		@Override
		protected Void doInBackground() throws Exception {
			builder = new QueryBuilder();

			configArtVonSport();
			configPrice();
			configKoerperlicheEinschraenkung();
			configInnenAussen();
			configZiele();
			config4Attributes();
			configTimeFrames();

			Map<String, Sportangebot> result = builder.execute();
			List<Sportangebot> result_sportangebote = new ArrayList<Sportangebot>(
					result.values());
			Collections.sort(result_sportangebote);
			for (Sportangebot sport : result_sportangebote) {
				model.addElement(sport);
			}

			return null;
		}
\end{lstlisting}

Die config-Methoden lesen zunächst die gewählten Optionen aus und bereiten diese für den QueryBuilder derart auf, dass einfach lesbare Datentypen entstehen. Der QueryBuilder gibt eine Menge von Key-Value-Paaren zurück, das aus den gematchten Sportbezeichnungen und der jeweils dazugehörigen Instanz besteht.

Der QueryBuilder führt nun sukzessiv bis zu 8 Queries aus, je nach dem, welche notwendig ist. Als erste die querySport, die alle Sportarten liefert, die sowohl in der Ontologie, als auch in der Datenbank sind. Die zweite Einschränkung käme, wenn Einzel oder Teamsport ausgewählt sind. Bei jeder Ontologie-Einschränkung wird die Query in der Form zusammengebaut: <NEUE QUERY> AND ( jeder Schlüsselwert in sport, getrennt durch OR ). Bei der Datenbank analog mit AND ( Sportangebot.name = 'Sport1' OR Sportangebot.name = 'Sport2' ... ) in der WHERE-Klausel.

Im folgenden 

		


begin{lstlisting}
    public Map<String, Sportangebot> execute() {
        Map<String, Sportangebot> sport = Queries.querySport();

        if (selectedArtVonSport == ArtVonSport.EINZELSPORT) {
            sport = Queries.queryEinzelsport(sport);
        } else if (selectedArtVonSport == ArtVonSport.TEAMSPORT) {
            sport = Queries.queryTeamsport(sport);
        }

        if (maximalPrice >= 0) {
            sport = Queries.queryPrice(sport, maximalPrice);
        }

        if (einschraenkungen.length > 0) {
            sport = Queries.queryFilterKoerperlicheEinschraenkungen(sport,
                                                                   einschraenkungen);
        }

        if (selectedInnenAussen != InnenAussen.EGAL) {
            boolean indoor = selectedInnenAussen == InnenAussen.INNEN;
            sport = Queries.queryIndoor(sport, indoor);
        }

        if (ziele.length > 0) {
            sport = Queries.queryZiele(sport, ziele);
        }

        if (timeFrames.size() > 0) {
            sport = Queries.queryTimeFrames(sport, getCompactTimeFrames());
        }

        sport = Queries.query4Attributes(sport, kampfsport, exotisch, koerperbetont, wassersport);

        return sport;

    }

end{lstlisting}


